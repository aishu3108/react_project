Do we use Topological Sort in THIS problem?
âœ… YES, conditionally

We use Topological Sort when steps have dependencies
Example:

S1 â†’ S2 â†’ S3


Here, S2 cannot start before S1, so order matters


ordering before scheduling 


kahns - BFS 

from collections import deque

def topo_sort(graph, indegree):
    q = deque()
    order = []

    for step in indegree:
        if indegree[step] == 0:
            q.append(step)

    while q:
        curr = q.popleft()
        order.append(curr)

        for nxt in graph[curr]:
            indegree[nxt] -= 1
            if indegree[nxt] == 0:
                q.append(nxt)

    return order

â€œYes, we use topological sort when step dependencies exist.
Steps form a DAG, and topological ordering ensures wafers follow correct processing order before scheduling machines.â€

Method	Uses	                Famous Name
DFS	Stack / recursion	DFS Topo
BFS	Queue + indegree	Kahnâ€™s Algorithm


How DFS Topo Works (Step-by-step)

Visit a node

Visit all its children

AFTER finishing children â†’ push node into stack

Reverse stack at end

â— DFS Topo â€” PROS & CONS
âœ… Pros

Simple

Very fast

Clean recursive logic

âŒ Cons (INTERVIEW TRAP âš ï¸)

âŒ Cannot detect cycles easily

âŒ Uses recursion (stack overflow risk)

âŒ Hard to simulate real-time scheduling

How BFS Topo Works

Count indegree of each node

Push indegree=0 nodes into queue

Pop â†’ reduce neighborsâ€™ indegree

Repeat

â€œBFS (Kahnâ€™s Algorithm), because it helps detect cycles and supports scheduling constraintsâ€


Why BFS Topo is BETTER for YOUR KLA Problem
Requirement	      DFS	BFS
Step dependency	       âœ…	âœ…
Cycle detection	       âŒ	âœ…
Scheduling machines	âŒ	âœ…
Cooldown / wait logic	âŒ	âœ…
Real-time availability	âŒ	âœ…

Both DFS and BFS can produce topological order, but for scheduling problems with dependencies and validation, BFS-based Kahnâ€™s algorithm is preferred because it detects cycles and aligns well with real-world pipeline execution.â€


What is â€œTopo Sort + Priority Queueâ€?

Topological Sort decides WHAT can run
Priority Queue decides WHAT should run FIRST

This combo is used in:

CPU scheduling

Build systems (Make, Bazel)

DAG job schedulers

Your KLA wafer scheduling


Why Topo Sort ALONE is NOT enough

Topo Sort only says:

â€œThese steps are allowed nowâ€

But it does NOT answer:

Which wafer first?

Which machine first?

Shorter job or longer job?

Faster machine or slower?

ğŸ‘‰ Thatâ€™s where Priority Queue (Min-Heap) comes in.


Many students raise hands (eligible tasks)

Rules:

Only students who finished homework can answer (Topo)

Among them, choose:

Fastest speaker

Or shortest answer

Or highest marks

That choosing = Priority Queue


ğŸ§± DATA STRUCTURES USED
Purpose	          Data Structure
Dependencies	        Graph (Adj list)
Dependency count	HashMap (indegree)
Ready tasks	        Priority Queue (Min Heap)
Machine availability	HashMap
Final schedule	List

Core Scheduling Logic
Step 1: Use BFS Topo to find READY steps
Step 2: Push READY tasks into Min-Heap
Step 3: Pick BEST task based on priority
Step 4: Schedule on earliest free machine
Step 5: Update dependencies & repeat

What can be the PRIORITY?

Common interview priorities:

â± Shortest Processing Time (SPT)

ğŸ•’ Earliest Start Time

ğŸ§Š Machine cooldown safety

âš¡ Least parameter drift

ğŸ§® Least slack time

ğŸ‘‰ For KLA:
Shortest Processing Time + Earliest Machine Free


Milestone	Technique
Milestone 0	Greedy
Milestone 1	Topo Sort
Milestone 2	Topo + PQ
Milestone 3	Topo + PQ + Constraints
Milestone 4	Simulation loop
Milestone 5	Full optimizerGreedy in YOUR KLA Problem

In Milestone 0, we used Greedy.

Why?

At each step:

Pick the earliest free machine

Process the next available wafer

Donâ€™t wait if something can run

That is greedy scheduling.
========

Greedy Rule in Scheduling

Common greedy choices:

Shortest job first

Earliest machine free

Lowest cooldown risk

Minimum parameter drift



Use Greedy when:

Problem explicitly allows greedy

Local choice is provably optimal

Real-time systems

Scheduling, routing, pipelines

Use DP when:

Choices affect future results

Multiple paths compete

Optimization problems

â€œMax / Min / Count waysâ€



In YOUR KLA Problem
Why Greedy works (initial milestones)

Tasks are independent per step

Machine availability dominates

We choose earliest free machine

Where DP could be used (but expensive)

Try all scheduling combinations

Parameter drift minimization

Cooldown optimization

ğŸ‘‰ But DP would be too slow for large wafers.

So industry prefers:

Greedy + Topo + Priority Queue


â€œGreedy algorithms make locally optimal decisions and are efficient, but they donâ€™t always guarantee optimal solutions. Dynamic programming explores all relevant subproblems and guarantees optimality at the cost of higher time and space complexity.â€




